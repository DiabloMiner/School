package com.diablominer.opengl.examples.learning;

import com.diablominer.opengl.utils.Transforms;
import org.jblas.DoubleMatrix;
import org.jblas.exceptions.SizeException;
import org.joml.Matrix4d;
import org.joml.Matrix4f;
import org.joml.Quaterniond;
import org.joml.Vector3d;
import org.junit.Test;

import java.util.*;
import java.util.stream.Collectors;

import static org.junit.Assert.*;

public class PhysicsEngineTest {

    public static double epsilon = 10e-10;

    /**
     * Tests if an error is thrown if matrix sizes are not correct.
     */
    @Test
    public void testReadEntityDataFalseSize() {
        Entity testEntity = new Entity("", new Component.Type[]{Component.Type.Physics},
                new Component[]{new PhysicsSphere(Material.Inelastic, new Vector3d(0.0, 0.10715, -0.5), new Vector3d(0.0, 10.0, 1.0),  new Quaterniond().identity(), new Vector3d(1 * (3.0/ 0.05715), 0.0, 0.0), new HashSet<>(Collections.singletonList(new Gravity())), 0.163, 0.05715, false)});
        PhysicsEngine testEngine = new PhysicsEngine(Collections.singletonList(testEntity), 0.0) {
            @Override
            void update() {
                DoubleMatrix MInv = new DoubleMatrix(6, 6), q = new DoubleMatrix(7, 1), u = new DoubleMatrix(6, 1),
                        fExt = new DoubleMatrix(6, 1), H = new DoubleMatrix(7, 6);
                readEntityData(entities, MInv, H, q, u, fExt);
            }

            @Override
            public void destroy() {}
        };

        try {
            testEngine.update();
            fail("No assertion error for false matrix sizes was thrown.");
        } catch (SizeException ignored) {}
    }

    /**
     * Tests if values are correctly read out in the case of one entity.
     */
    @Test
    public void testReadEntityDataSingle() {
        Entity testEntity = new Entity("", new Component.Type[]{Component.Type.Physics},
                new Component[]{new PhysicsSphere(Material.Inelastic, new Vector3d(0.0, 0.10715, -0.5), new Vector3d(0.0, 10.0, 1.0),  new Quaterniond().identity(), new Vector3d(1 * (3.0/ 0.05715), 0.0, 0.0), new HashSet<>(Collections.singletonList(new Gravity())), 0.163, 0.05715, false)});
        DoubleMatrix MInv = new DoubleMatrix(6, 6), q = new DoubleMatrix(7, 1), u = new DoubleMatrix(6, 1),
                fExt = new DoubleMatrix(6, 1), H = new DoubleMatrix(7, 6);
        PhysicsEngine testEngine = new PhysicsEngine(Collections.singletonList(testEntity), 0.0) {@Override void update() {} @Override public void destroy() {}};

        testEngine.readEntityData(testEngine.entities, u, q, fExt, MInv, H);

        assertArrayEquals(H.toArray(), new DoubleMatrix(new double[][]{
                {1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
                {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
                {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
                {0.0, 0.0, 0.0, -0.0, -0.0, -0.5},
                {0.0, 0.0, 0.0, 0.0, 0.5, -0.0},
                {0.0, 0.0, 0.0, -0.5, 0.0, 0.0},
                {0.0, 0.0, 0.0, 0.0, -0.0, 0.0}
        }).toArray(), epsilon);
        assertArrayEquals(MInv.toArray(), new DoubleMatrix(new double[][]{
                {6.134969325153374, 0.0, 0.0, 0.0, 0.0, 0.0},
                {0.0, 6.134969325153374, 0.0, 0.0, 0.0, 0.0},
                {0.0, 0.0, 6.134969325153374, 0.0, 0.0, 0.0},
                {0.0, 0.0, 0.0, 4695.91183823737, 0.0, 0.0},
                {0.0, 0.0, 0.0, 0.0, 4695.91183823737, 0.0},
                {0.0, 0.0, 0.0, 0.0, 0.0, 4695.91183823737}
        }).toArray(), epsilon);
        assertArrayEquals(q.toArray(), new double[] {0.0, 0.10715, -0.5, 0.0, 0.0, 0.0, 1.0}, epsilon);
        assertArrayEquals(u.toArray(), new double[] {0.0, 10.0, 1.0, 52.493438320209975, 0.0, 0.0}, epsilon);
        assertArrayEquals(fExt.toArray(), new double[] {0.0, -1.5990300000000002, 0.0, 0.0, 0.0, 0.0}, epsilon);
    }

    /**
     * Tests if values are correctly read out in the case of multiple entities.
     */
    @Test
    public void testReadEntityDataMultiple() {
        Entity testEntity1 = new Entity("1", new Component.Type[]{Component.Type.Physics},
                new Component[]{new PhysicsSphere(Material.Inelastic, new Vector3d(0.0, 0.10715, -0.5), new Vector3d(0.0, 10.0, 1.0),  new Quaterniond().identity(), new Vector3d(1 * (3.0/ 0.05715), 0.0, 0.0), new HashSet<>(Collections.singletonList(new Gravity())), 0.163, 0.05715, false)});
        Entity testEntity2 = new Entity("2", new Component.Type[]{Component.Type.Physics},
                new Component[]{new PhysicsSphere(Material.Inelastic, new Vector3d(0.0, 0.10715, 0.5), new Vector3d(0.0, 10.0, -0.8),  new Quaterniond().identity(), new Vector3d(-0.8 * (3.0/ 0.05715), 0.0, 0.0), new HashSet<>(Collections.singletonList(new Gravity())), 0.163, 0.05715, false)});
        Entity testEntity3 = new Entity("3", new Component.Type[]{Component.Type.Physics},
                new Component[]{new PhysicsBox(new Matrix4d().translate(0.0, 0.0, 0.0), new Vector3d(1.378 / 2, 0.05, 2.648 / 2), new Vector3d(1.378, 0.1, 2.648), Material.Rail, new Vector3d(), new Vector3d(), new HashSet<>(), 5.97219e24, false)});
        Entity testEntity4 = new Entity("4", new Component.Type[]{Component.Type.Physics},
                new Component[]{new PhysicsBox(new Matrix4d().translate(0.0, 0.136 - 0.05, -2.594 / 2), new Vector3d(1.378 / 2, 0.036, 0.054 / 2), new Vector3d(0.054, 0.072, 1.378), Material.Rail, new Vector3d(), new Vector3d(), new HashSet<>(), 5.97219e24, false)});
        Entity testEntity5 = new Entity("5", new Component.Type[]{Component.Type.Physics},
                new Component[]{new PhysicsBox(new Matrix4d().translate(0.0, 0.136 - 0.05, 2.594 / 2), new Vector3d(1.378 / 2, 0.036, 0.054 / 2), new Vector3d(0.054, 0.072, 1.378), Material.Rail, new Vector3d(), new Vector3d(), new HashSet<>(), 5.97219e24, false)});
        Entity testEntity6 = new Entity("6", new Component.Type[]{Component.Type.Physics},
                new Component[]{new PhysicsBox(new Matrix4d().translate(1.324 / 2, 0.136 - 0.05, 0.0), new Vector3d(0.054 / 2, 0.036, 2.54 / 2), new Vector3d(2.54, 0.072, 0.054), Material.Rail, new Vector3d(), new Vector3d(), new HashSet<>(), 5.97219e24, false)});
        Entity testEntity7 = new Entity("7", new Component.Type[]{Component.Type.Physics},
                new Component[]{new PhysicsBox(new Matrix4d().translate(-1.324 / 2, 0.136 - 0.05, 0.0), new Vector3d(0.054 / 2, 0.036, 2.54 / 2), new Vector3d(2.54, 0.072, 0.054), Material.Rail, new Vector3d(), new Vector3d(), new HashSet<>(), 5.97219e24, false)});
        PhysicsEngine testEngine = new PhysicsEngine(Arrays.asList(testEntity1, testEntity2, testEntity3, testEntity4, testEntity5, testEntity6, testEntity7), 0.0) {@Override void update() {} @Override public void destroy() {}};

        int n = testEngine.entities.size();
        DoubleMatrix MInv = new DoubleMatrix(n * 6, n * 6), q = new DoubleMatrix(n * 7, 1), u = new DoubleMatrix(n * 6, 1),
                fExt = new DoubleMatrix(n * 6, 1), H = new DoubleMatrix(n * 7, n * 6);
        testEngine.readEntityData(testEngine.entities, u, q, fExt, MInv, H);

        assertArrayEquals(H.toArray(), new double[] {1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.0, 0.0, -0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.0, 0.5, 0.0, -0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.5, -0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.0, 0.0, -0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.0, 0.5, 0.0, -0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.5, -0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.0, 0.0, -0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.0, 0.5, 0.0, -0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.5, -0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.0, 0.0, -0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.0, 0.5, 0.0, -0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.5, -0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.0, 0.0, -0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.0, 0.5, 0.0, -0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.5, -0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.0, 0.0, -0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.0, 0.5, 0.0, -0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.5, -0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.0, 0.0, -0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.0, 0.5, 0.0, -0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.5, -0.0, 0.0, 0.0}, epsilon);
        assertArrayEquals(MInv.toArray(), new double[] {6.134969325153374, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 6.134969325153374, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 6.134969325153374, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 4695.91183823737, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 4695.91183823737, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 4695.91183823737, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 6.134969325153374, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 6.134969325153374, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 6.134969325153374, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 4695.91183823737, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 4695.91183823737, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 4695.91183823737, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.6744276387723765E-25, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.6744276387723765E-25, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.6744276387723765E-25, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 2.8614933592467965E-25, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 2.254921973821902E-25, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0526114559747226E-24, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.6744276387723765E-25, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.6744276387723765E-25, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.6744276387723765E-25, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0552738486896748E-24, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0565323201844843E-24, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 2.4806335389220395E-22, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.6744276387723765E-25, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.6744276387723765E-25, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.6744276387723765E-25, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0552738486896748E-24, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0565323201844843E-24, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 2.4806335389220395E-22, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.6744276387723765E-25, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.6744276387723765E-25, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.6744276387723765E-25, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 2.4806335389220395E-22, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 3.1130346048051504E-25, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 3.1119411250660576E-25, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.6744276387723765E-25, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.6744276387723765E-25, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.6744276387723765E-25, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 2.4806335389220395E-22, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 3.1130346048051504E-25, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 3.1119411250660576E-25}, epsilon);
        assertArrayEquals(q.toArray(), new double[] {0.0, 0.10715, -0.5, 0.0, 0.0, 0.0, 1.0, 0.0, 0.10715, 0.5, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.08600000000000001, -1.297, 0.0, 0.0, 0.0, 1.0, 0.0, 0.08600000000000001, 1.297, 0.0, 0.0, 0.0, 1.0, 0.662, 0.08600000000000001, 0.0, 0.0, 0.0, 0.0, 1.0, -0.662, 0.08600000000000001, 0.0, 0.0, 0.0, 0.0, 1.0}, epsilon);
        assertArrayEquals(u.toArray(), new double[] {0.0, 10.0, 1.0, 52.493438320209975, 0.0, 0.0, 0.0, 10.0, -0.8, -41.99475065616798, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}, epsilon);
        assertArrayEquals(fExt.toArray(), new double[] {0.0, -1.5990300000000002, 0.0, 0.0, 0.0, 0.0, 0.0, -1.5990300000000002, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}, epsilon);
    }

    /**
     * Tests if an error is thrown if matrix sizes are not correct.
     */
    @Test
    public void testWriteEntityDataFalseSize() {
        Entity testEntity = new Entity("", new Component.Type[]{Component.Type.Physics},
                new Component[]{new PhysicsSphere(Material.Inelastic, new Vector3d(0.0, 0.10715, -0.5), new Vector3d(0.0, 10.0, 1.0),  new Quaterniond().identity(), new Vector3d(1 * (3.0/ 0.05715), 0.0, 0.0), new HashSet<>(Collections.singletonList(new Gravity())), 0.163, 0.05715, false)});
        PhysicsEngine testEngine = new PhysicsEngine(Collections.singletonList(testEntity), 0.0) {
            @Override
            void update() {
                DoubleMatrix uNext = new DoubleMatrix(new double[] {0.0, 9.9019, 1.0, 52.493438320209975, 0.0, 0.0}), qNext = new DoubleMatrix(new double[] {0.0, 0.206169, -0.49, 0.0, 0.0, -0.5249343832020997, 1.0});
                writeEntityData(entities, qNext, uNext);
            }

            @Override
            public void destroy() {}
        };

        try {
            testEngine.update();
            fail("No assertion error for false matrix sizes was thrown.");
        } catch (SizeException ignored) {}
    }

    /**
     * Tests if values are correctly written to one entity.
     * This test assumes Transforms' functions to convert joml vectors/matrices to JBLAS matrices work.
     */
    @Test
    public void testWriteEntityDataSingle() {
        PhysicsComponent testPhysComp = new PhysicsSphere(Material.Inelastic, new Vector3d(0.0, 0.10715, -0.5), new Vector3d(0.0, 10.0, 1.0),  new Quaterniond().identity(), new Vector3d(1 * (3.0/ 0.05715), 0.0, 0.0), new HashSet<>(Collections.singletonList(new Gravity())), 0.163, 0.05715, false);
        Entity testEntity = new Entity("", new Component.Type[]{Component.Type.Physics},
                new Component[]{testPhysComp});
        PhysicsEngine testEngine = new PhysicsEngine(Collections.singletonList(testEntity), 0.0) {@Override void update() {} @Override public void destroy() {}};

        DoubleMatrix uNext = new DoubleMatrix(new double[] {0.0, 9.9019, 1.0, 52.493438320209975, 0.0, 0.0}), qNext = new DoubleMatrix(new double[] {0.0, 0.206169, -0.49, 0.0, 0.0, -0.5249343832020997, 1.0});
        testEngine.writeEntityData(testEngine.entities, uNext, qNext);

        assertArrayEquals(Transforms.jomlVectorToJBLASVector(testPhysComp.velocity).toArray(), new double[] {0.0, 9.9019, 1.0}, epsilon);
        assertArrayEquals(Transforms.jomlVectorToJBLASVector(testPhysComp.angularVelocity).toArray(), new double[] {52.493438320209975, 0.0, 0.0}, epsilon);
        assertArrayEquals(Transforms.jomlVectorToJBLASVector(testPhysComp.position).toArray(), new double[] {0.0, 0.206169, -0.49}, epsilon);
        assertArrayEquals(Transforms.jomlQuaternionToJBLASVector(testPhysComp.orientation).toArray(), new double[] {0.0, 0.0, -0.46478835321536943, 0.8854218128752788}, epsilon);
        assertArrayEquals(Transforms.jomlMatrixToJBLASMatrix(testPhysComp.worldMatrix).toArray(), new double[] {0.5679435734306901, -0.8230674926145356, -0.0, 0.0, 0.8230674926145356, 0.5679435734306901, 0.0, 0.0, 0.0, -0.0, 1.0000000000000002, 0.0, 0.0, 0.206169, -0.49, 1.0}, epsilon);
        assertArrayEquals(Transforms.jomlMatrixToJBLASMatrix(testPhysComp.worldFrameInertia).toArray(), new double[] {2.129511870000001E-4, 0.0, 0.0, 0.0, 2.129511870000001E-4, 0.0, 0.0, 0.0, 2.1295118700000013E-4}, epsilon);
        assertArrayEquals(Transforms.jomlMatrixToJBLASMatrix(testPhysComp.worldFrameInertiaInv).toArray(), new double[] {4695.911838237368, 0.0, 0.0, 0.0, 4695.911838237368, 0.0, 0.0, 0.0, 4695.911838237368}, epsilon);
    }

    /**
     * Tests if values are correctly written to multiple entities.
     * This test assumes Transforms' functions to convert joml vectors/matrices to JBLAS matrices work.
     */
    @Test
    public void testWriteEntityDataMultiple() {
        Entity testEntity1 = new Entity("1", new Component.Type[]{Component.Type.Physics},
                new Component[]{new PhysicsSphere(Material.Inelastic, new Vector3d(0.0, 0.10715, -0.5), new Vector3d(0.0, 10.0, 1.0),  new Quaterniond().identity(), new Vector3d(1 * (3.0/ 0.05715), 0.0, 0.0), new HashSet<>(Collections.singletonList(new Gravity())), 0.163, 0.05715, false)});
        Entity testEntity2 = new Entity("2", new Component.Type[]{Component.Type.Physics},
                new Component[]{new PhysicsSphere(Material.Inelastic, new Vector3d(0.0, 0.10715, 0.5), new Vector3d(0.0, 10.0, -0.8),  new Quaterniond().identity(), new Vector3d(-0.8 * (3.0/ 0.05715), 0.0, 0.0), new HashSet<>(Collections.singletonList(new Gravity())), 0.163, 0.05715, false)});
        Entity testEntity3 = new Entity("3", new Component.Type[]{Component.Type.Physics},
                new Component[]{new PhysicsBox(new Matrix4d().translate(0.0, 0.0, 0.0), new Vector3d(1.378 / 2, 0.05, 2.648 / 2), new Vector3d(1.378, 0.1, 2.648), Material.Rail, new Vector3d(), new Vector3d(), new HashSet<>(), 5.97219e24, false)});
        Entity testEntity4 = new Entity("4", new Component.Type[]{Component.Type.Physics},
                new Component[]{new PhysicsBox(new Matrix4d().translate(0.0, 0.136 - 0.05, -2.594 / 2), new Vector3d(1.378 / 2, 0.036, 0.054 / 2), new Vector3d(0.054, 0.072, 1.378), Material.Rail, new Vector3d(), new Vector3d(), new HashSet<>(), 5.97219e24, false)});
        Entity testEntity5 = new Entity("5", new Component.Type[]{Component.Type.Physics},
                new Component[]{new PhysicsBox(new Matrix4d().translate(0.0, 0.136 - 0.05, 2.594 / 2), new Vector3d(1.378 / 2, 0.036, 0.054 / 2), new Vector3d(0.054, 0.072, 1.378), Material.Rail, new Vector3d(), new Vector3d(), new HashSet<>(), 5.97219e24, false)});
        Entity testEntity6 = new Entity("6", new Component.Type[]{Component.Type.Physics},
                new Component[]{new PhysicsBox(new Matrix4d().translate(1.324 / 2, 0.136 - 0.05, 0.0), new Vector3d(0.054 / 2, 0.036, 2.54 / 2), new Vector3d(2.54, 0.072, 0.054), Material.Rail, new Vector3d(), new Vector3d(), new HashSet<>(), 5.97219e24, false)});
        Entity testEntity7 = new Entity("7", new Component.Type[]{Component.Type.Physics},
                new Component[]{new PhysicsBox(new Matrix4d().translate(-1.324 / 2, 0.136 - 0.05, 0.0), new Vector3d(0.054 / 2, 0.036, 2.54 / 2), new Vector3d(2.54, 0.072, 0.054), Material.Rail, new Vector3d(), new Vector3d(), new HashSet<>(), 5.97219e24, false)});
        PhysicsEngine testEngine = new PhysicsEngine(Arrays.asList(testEntity1, testEntity2, testEntity3, testEntity4, testEntity5, testEntity6, testEntity7), 0.0) {@Override void update() {} @Override public void destroy() {}};

        DoubleMatrix uNext = new DoubleMatrix(new double[] {0.0, 9.9019, 1.0, 52.493438320209975, 0.0, 0.0, 0.0, 9.9019, -0.8, -41.99475065616798, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}),
                qNext = new DoubleMatrix(new double[] {0.0, 0.206169, -0.49, 0.0, 0.0, -0.5249343832020997, 1.0, 0.0, 0.206169, 0.492, 0.0, 0.0, 0.4199475065616798, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.08600000000000001, -1.297, 0.0, 0.0, 0.0, 1.0, 0.0, 0.08600000000000001, 1.297, 0.0, 0.0, 0.0, 1.0, 0.662, 0.08600000000000001, 0.0, 0.0, 0.0, 0.0, 1.0, -0.662, 0.08600000000000001, 0.0, 0.0, 0.0, 0.0, 1.0});
        double[][] v = new double[][] {{0.0, 9.9019, 1.0}, {0.0, 9.9019, -0.8}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}};
        double[][] av = new double[][] {{52.493438320209975, 0.0, 0.0}, {-41.99475065616798, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}};
        double[][] x = new double[][] {{0.0, 0.206169, -0.49}, {0.0, 0.206169, 0.492}, {0.0, 0.0, 0.0}, {0.0, 0.08600000000000001, -1.297}, {0.0, 0.08600000000000001, 1.297}, {0.662, 0.08600000000000001, 0.0}, {-0.662, 0.08600000000000001, 0.0}};
        double[][] q = new double[][] {{0.0, 0.0, -0.46478835321536943, 0.8854218128752788}, {0.0, 0.0, 0.3871913424209367, 0.9219993841398556}, {0.0, 0.0, 0.0, 1.0}, {0.0, 0.0, 0.0, 1.0}, {0.0, 0.0, 0.0, 1.0}, {0.0, 0.0, 0.0, 1.0}, {0.0, 0.0, 0.0, 1.0}};
        double[][] wm = new double[][] {{0.5679435734306901, -0.8230674926145356, -0.0, 0.0, 0.8230674926145356, 0.5679435734306901, 0.0, 0.0, 0.0, -0.0, 1.0000000000000002, 0.0, 0.0, 0.206169, -0.49, 1.0}, {0.700165728708546, 0.7139803585127752, 0.0, 0.0, -0.7139803585127752, 0.700165728708546, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.206169, 0.492, 1.0}, {1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0}, {1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.08600000000000001, -1.297, 1.0}, {1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.08600000000000001, 1.297, 1.0}, {1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.662, 0.08600000000000001, 0.0, 1.0}, {1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, -0.662, 0.08600000000000001, 0.0, 1.0}};
        double[][] wfi = new double[][] {{2.129511870000001E-4, 0.0, 0.0, 0.0, 2.129511870000001E-4, 0.0, 0.0, 0.0, 2.1295118700000013E-4}, {2.1295118700000008E-4, 0.0, 0.0, 0.0, 2.1295118700000008E-4, 0.0, 0.0, 0.0, 2.1295118700000003E-4}, {3.49467873748E24, 0.0, 0.0, 0.0, 4.43474324881E24, 0.0, 0.0, 0.0, 9.500181613299999E23}, {9.4762132241E23, 0.0, 0.0, 0.0, 9.464925784999998E23, 0.0, 0.0, 0.0, 4.0312282499999995E21}, {9.4762132241E23, 0.0, 0.0, 0.0, 9.464925784999998E23, 0.0, 0.0, 0.0, 4.0312282499999995E21}, {4.0312282499999995E21, 0.0, 0.0, 0.0, 3.21229965917E24, 0.0, 0.0, 0.0, 3.2134284030799997E24}, {4.0312282499999995E21, 0.0, 0.0, 0.0, 3.21229965917E24, 0.0, 0.0, 0.0, 3.2134284030799997E24}};
        double[][] wfii = new double[][] {{4695.911838237368, 0.0, 0.0, 0.0, 4695.911838237368, 0.0, 0.0, 0.0, 4695.911838237368}, {4695.911838237368, 0.0, 0.0, 0.0, 4695.911838237368, 0.0, 0.0, 0.0, 4695.911838237369}, {2.8614933592467965E-25, 0.0, 0.0, 0.0, 2.254921973821902E-25, 0.0, 0.0, 0.0, 1.0526114559747226E-24}, {1.0552738486896748E-24, 0.0, 0.0, 0.0, 1.0565323201844843E-24, 0.0, 0.0, 0.0, 2.4806335389220395E-22}, {1.0552738486896748E-24, 0.0, 0.0, 0.0, 1.0565323201844843E-24, 0.0, 0.0, 0.0, 2.4806335389220395E-22}, {2.4806335389220395E-22, 0.0, 0.0, 0.0, 3.1130346048051504E-25, 0.0, 0.0, 0.0, 3.1119411250660576E-25}, {2.4806335389220395E-22, 0.0, 0.0, 0.0, 3.1130346048051504E-25, 0.0, 0.0, 0.0, 3.1119411250660576E-25}};
        testEngine.writeEntityData(testEngine.entities, uNext, qNext);

        for (int i = 0; i < testEngine.entities.size(); i++) {
            PhysicsComponent testPhysComp = testEngine.entities.get(i).getPhysicsComponent();

            assertArrayEquals(Transforms.jomlVectorToJBLASVector(testPhysComp.velocity).toArray(), v[i], epsilon);
            assertArrayEquals(Transforms.jomlVectorToJBLASVector(testPhysComp.angularVelocity).toArray(), av[i], epsilon);
            assertArrayEquals(Transforms.jomlVectorToJBLASVector(testPhysComp.position).toArray(), x[i], epsilon);
            assertArrayEquals(Transforms.jomlQuaternionToJBLASVector(testPhysComp.orientation).toArray(), q[i], epsilon);
            assertArrayEquals(Transforms.jomlMatrixToJBLASMatrix(testPhysComp.worldMatrix).toArray(), wm[i], epsilon);
            assertArrayEquals(Transforms.jomlMatrixToJBLASMatrix(testPhysComp.worldFrameInertia).toArray(), wfi[i], epsilon);
            assertArrayEquals(Transforms.jomlMatrixToJBLASMatrix(testPhysComp.worldFrameInertiaInv).toArray(), wfii[i], epsilon);
        }
    }

    /**
     * Tests if a timestep for a single entity without collisions produces correct results.
     */
    @Test
    public void testTimeStepSingle() {
        Force gravityTorque = new Force() {
            final double accelerationConstant = 9.81;

            @Override
            public boolean isFulfilled(PhysicsComponent physicsComponent) {
                return true;
            }

            @Override
            public Map.Entry<Vector3d, Vector3d> applyForce(PhysicsComponent physicsComponent) {
                return new AbstractMap.SimpleEntry<>(new Vector3d(0.0, -accelerationConstant, 0.0).mul(physicsComponent.mass), new Vector3d(0.0, -2 * Math.PI, 0.0));
            }
        };
        PhysicsComponent testPhysComp = new PhysicsSphere(Material.Inelastic, new Vector3d(0.0, 0.10715, -0.5), new Vector3d(0.0, 10.0, 1.0),  new Quaterniond().identity(), new Vector3d(0.0, 0.0, 0.0), new HashSet<>(Collections.singletonList(gravityTorque)), 0.163, 0.05715, false);
        Entity testEntity = new Entity("", new Component.Type[]{Component.Type.Physics},
                new Component[]{testPhysComp});
        PhysicsEngine testEngine = new PhysicsEngine(Collections.singletonList(testEntity), 0.0) {
            @Override void update() { timeStep(0.01); }
            @Override public void destroy() { }
        };

        testEngine.update();

        assertArrayEquals(Transforms.jomlVectorToJBLASVector(testPhysComp.velocity).toArray(), new double[] {0.0, 9.9019, 1.0}, epsilon);
        assertArrayEquals(Transforms.jomlVectorToJBLASVector(testPhysComp.angularVelocity).toArray(), new double[] {0.0, -295.05284265823724, 0.0}, epsilon);
        assertArrayEquals(Transforms.jomlVectorToJBLASVector(testPhysComp.position).toArray(), new double[] {0.0, 0.206169, -0.49}, epsilon);
        assertArrayEquals(Transforms.jomlQuaternionToJBLASVector(testPhysComp.orientation).toArray(), new double[] {0.0, -0.8277551782105788, 0.0, 0.5610894446927096}, epsilon);
        assertArrayEquals(Transforms.jomlMatrixToJBLASMatrix(testPhysComp.worldMatrix).toArray(), new double[] {-0.37035727010885355, 0.0, 0.9288893865673766, 0.0, -0.0, 0.9999999999999998, 0.0, 0.0, -0.9288893865673766, -0.0, -0.37035727010885355, 0.0, 0.0, 0.206169, -0.49, 1.0}, epsilon);
        assertArrayEquals(Transforms.jomlMatrixToJBLASMatrix(testPhysComp.worldFrameInertia).toArray(), new double[] {2.1295118699999992E-4, -0.0, -1.3552527156068805E-20, 0.0, 2.1295118699999992E-4, 0.0, 1.3552527156068805E-20, 0.0, 2.1295118699999992E-4}, epsilon);
        assertArrayEquals(Transforms.jomlMatrixToJBLASMatrix(testPhysComp.worldFrameInertiaInv).toArray(), new double[] {4695.911838237372, 0.0, 2.988547451027685E-13, 0.0, 4695.911838237372, -0.0, -2.988547451027685E-13, -0.0, 4695.911838237372}, epsilon);
    }

    /**
     * Tests if a timestep for a multiple entities without collisions produces correct results.
     */
    @Test
    public void testTimeStepMultiple() {
        Force gravityTorque = new Force() {
            final double accelerationConstant = 9.81;

            @Override
            public boolean isFulfilled(PhysicsComponent physicsComponent) {
                return true;
            }

            @Override
            public Map.Entry<Vector3d, Vector3d> applyForce(PhysicsComponent physicsComponent) {
                return new AbstractMap.SimpleEntry<>(new Vector3d(0.0, -accelerationConstant, 0.0).mul(physicsComponent.mass), new Vector3d(0.0, -2 * Math.PI, 0.0));
            }
        };
        Entity testEntity1 = new Entity("1", new Component.Type[]{Component.Type.Physics},
                new Component[]{new PhysicsSphere(Material.Inelastic, new Vector3d(0.0, 0.10715, -0.5), new Vector3d(0.0, 10.0, 1.0),  new Quaterniond().identity(), new Vector3d(1 * (3.0/ 0.05715), 0.0, 0.0), new HashSet<>(Collections.singletonList(gravityTorque)), 0.163, 0.05715, false)});
        Entity testEntity2 = new Entity("2", new Component.Type[]{Component.Type.Physics},
                new Component[]{new PhysicsSphere(Material.Inelastic, new Vector3d(0.0, 0.10715, 0.5), new Vector3d(0.0, 10.0, -0.8),  new Quaterniond().identity(), new Vector3d(-0.8 * (3.0/ 0.05715), 0.0, 0.0), new HashSet<>(Collections.singletonList(gravityTorque)), 0.163, 0.05715, false)});
        Entity testEntity3 = new Entity("3", new Component.Type[]{Component.Type.Physics},
                new Component[]{new PhysicsBox(new Matrix4d().translate(0.0, 50.0, 0.0), new Vector3d(1.378 / 2, 0.05, 2.648 / 2), new Vector3d(1.378, 0.1, 2.648), Material.Rail, new Vector3d(), new Vector3d(), new HashSet<>(), 5.97219e24, false)});
        Entity testEntity4 = new Entity("4", new Component.Type[]{Component.Type.Physics},
                new Component[]{new PhysicsBox(new Matrix4d().translate(0.0, 25.136 - 0.05, -2.594 / 2), new Vector3d(1.378 / 2, 0.036, 0.054 / 2), new Vector3d(0.054, 0.072, 1.378), Material.Rail, new Vector3d(), new Vector3d(), new HashSet<>(), 5.97219e24, false)});
        Entity testEntity5 = new Entity("5", new Component.Type[]{Component.Type.Physics},
                new Component[]{new PhysicsBox(new Matrix4d().translate(0.0, -25.136 - 0.05, 2.594 / 2), new Vector3d(1.378 / 2, 0.036, 0.054 / 2), new Vector3d(0.054, 0.072, 1.378), Material.Rail, new Vector3d(), new Vector3d(), new HashSet<>(), 5.97219e24, false)});
        Entity testEntity6 = new Entity("6", new Component.Type[]{Component.Type.Physics},
                new Component[]{new PhysicsBox(new Matrix4d().translate(1.324 / 2, -50.136 - 0.05, 0.0), new Vector3d(0.054 / 2, 0.036, 2.54 / 2), new Vector3d(2.54, 0.072, 0.054), Material.Rail, new Vector3d(), new Vector3d(), new HashSet<>(), 5.97219e24, false)});
        Entity testEntity7 = new Entity("7", new Component.Type[]{Component.Type.Physics},
                new Component[]{new PhysicsBox(new Matrix4d().translate(-1.324 / 2, 100.136 - 0.05, 0.0), new Vector3d(0.054 / 2, 0.036, 2.54 / 2), new Vector3d(2.54, 0.072, 0.054), Material.Rail, new Vector3d(), new Vector3d(), new HashSet<>(), 5.97219e24, false)});
        PhysicsEngine testEngine = new PhysicsEngine(Arrays.asList(testEntity1, testEntity2, testEntity3, testEntity4, testEntity5, testEntity6, testEntity7), 0.0) {
            @Override void update() { timeStep(0.01); }
            @Override public void destroy() { }
        };

        testEngine.update();

        double[][] v = new double[][] {{0.0, 9.9019, 1.0}, {0.0, 9.9019, -0.8}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}};
        double[][] av = new double[][] {{52.493438320209975, -295.05284265823724, 0.0}, {-41.99475065616798, -295.05284265823724, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}};
        double[][] x = new double[][] {{0.0, 0.206169, -0.49}, {0.0, 0.206169, 0.492}, {0.0, 50.0, 0.0}, {0.0, 25.08600000000000001, -1.297}, {0.0, -25.18600000000000001, 1.297}, {0.662, -50.18600000000000001, 0.0}, {-0.662, 100.08600000000000001, 0.0}};
        double[][] q = new double[][] {{0.0, -0.8189225230900957, -0.14569613553818284, 0.5551022764004766}, {0.0, -0.822069613773467, 0.11700483256288079, 0.5572355150807198}, {0.0, 0.0, 0.0, 1.0}, {0.0, 0.0, 0.0, 1.0}, {0.0, 0.0, 0.0, 1.0}, {0.0, 0.0, 0.0, 1.0}, {0.0, 0.0, 0.0, 1.0}};
        double[][] wm = new double[][] {{-0.3837229254700178, -0.16175251299999535, 0.909171513525868, 0.0, 0.16175251299999535, 0.957545272178479, 0.2386276938388105, 0.0, -0.909171513525868, 0.2386276938388105, -0.34126819764849675, 0.0, 0.0, 0.206169, -0.49, 1.0}, {-0.37897716146544985, 0.1303984962802205, 0.9161727693265325, 0.0, -0.1303984962802205, 0.9726197383138645, -0.19237223502919315, 0.0, -0.9161727693265325, -0.19237223502919315, -0.3515968997793143, 0.0, 0.0, 0.206169, 0.492, 1.0}, {1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 50.0, 0.0, 1.0}, {1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 25.086, -1.297, 1.0}, {1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, -25.186, 1.297, 1.0}, {1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.662, -50.186, 0.0, 1.0}, {1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, -0.662, 100.086, 0.0, 1.0}};
        double[][] wfi = new double[][] {{2.1295118700000005E-4, 0.0, 0.0, 5.082197683525802E-21, 2.1295118700000003E-4, -6.776263578034403E-21, 1.3552527156068805E-20, -1.3552527156068805E-20, 2.1295118700000005E-4}, {2.1295118700000003E-4, -3.3881317890172014E-21, 1.3552527156068805E-20, 0.0, 2.1295118700000005E-4, -6.776263578034403E-21, 0.0, -1.0164395367051604E-20, 2.1295118700000003E-4}, {3.49467873748E24, 0.0, 0.0, 0.0, 4.43474324881E24, 0.0, 0.0, 0.0, 9.500181613299999E23}, {9.4762132241E23, 0.0, 0.0, 0.0, 9.464925784999998E23, 0.0, 0.0, 0.0, 4.0312282499999995E21}, {9.4762132241E23, 0.0, 0.0, 0.0, 9.464925784999998E23, 0.0, 0.0, 0.0, 4.0312282499999995E21}, {4.0312282499999995E21, 0.0, 0.0, 0.0, 3.21229965917E24, 0.0, 0.0, 0.0, 3.2134284030799997E24}, {4.0312282499999995E21, 0.0, 0.0, 0.0, 3.21229965917E24, 0.0, 0.0, 0.0, 3.2134284030799997E24}};
        double[][] wfii = new double[][] {{4695.911838237369, -0.0, -0.0, -1.1207052941353807E-13, 4695.91183823737, 1.494273725513841E-13, -2.9885474510276816E-13, 2.988547451027682E-13, 4695.911838237369}, {4695.91183823737, 7.471368627569203E-14, -2.9885474510276826E-13, -0.0, 4695.91183823737, 1.494273725513841E-13, -0.0, 2.2414105882707617E-13, 4695.91183823737}, {2.8614933592467965E-25, 0.0, 0.0, 0.0, 2.254921973821902E-25, 0.0, 0.0, 0.0, 1.0526114559747226E-24}, {1.0552738486896748E-24, 0.0, 0.0, 0.0, 1.0565323201844843E-24, 0.0, 0.0, 0.0, 2.4806335389220395E-22}, {1.0552738486896748E-24, 0.0, 0.0, 0.0, 1.0565323201844843E-24, 0.0, 0.0, 0.0, 2.4806335389220395E-22}, {2.4806335389220395E-22, 0.0, 0.0, 0.0, 3.1130346048051504E-25, 0.0, 0.0, 0.0, 3.1119411250660576E-25}, {2.4806335389220395E-22, 0.0, 0.0, 0.0, 3.1130346048051504E-25, 0.0, 0.0, 0.0, 3.1119411250660576E-25}};

        for (int i = 0; i < testEngine.entities.size(); i++) {
            PhysicsComponent testPhysComp = testEngine.entities.get(i).getPhysicsComponent();

            assertArrayEquals(Transforms.jomlVectorToJBLASVector(testPhysComp.velocity).toArray(), v[i], epsilon);
            assertArrayEquals(Transforms.jomlVectorToJBLASVector(testPhysComp.angularVelocity).toArray(), av[i], epsilon);
            assertArrayEquals(Transforms.jomlVectorToJBLASVector(testPhysComp.position).toArray(), x[i], epsilon);
            assertArrayEquals(Transforms.jomlQuaternionToJBLASVector(testPhysComp.orientation).toArray(), q[i], epsilon);
            assertArrayEquals(Transforms.jomlMatrixToJBLASMatrix(testPhysComp.worldMatrix).toArray(), wm[i], epsilon);
            assertArrayEquals(Transforms.jomlMatrixToJBLASMatrix(testPhysComp.worldFrameInertia).toArray(), wfi[i], epsilon);
            assertArrayEquals(Transforms.jomlMatrixToJBLASMatrix(testPhysComp.worldFrameInertiaInv).toArray(), wfii[i], epsilon);
        }
    }

    /**
     * Test if contacts are generated and retrieved correctly
     */
    @Test
    public void testGetContacts() {
        Entity testEntity1 = new Entity("1", new Component.Type[]{Component.Type.Physics},
                new Component[]{new PhysicsSphere(Material.Inelastic, new Vector3d(0.0, 0.10715, -0.5), new Vector3d(0.0, 0.0, 0.0),  new Quaterniond().identity(), new Vector3d(0.0 * (3.0/ 0.05715), 0.0, 0.0), new HashSet<>(Collections.singletonList(new Gravity())), 0.163, 0.05715, false)});
        Entity testEntity2 = new Entity("3", new Component.Type[]{Component.Type.Physics},
                new Component[]{new PhysicsBox(new Matrix4d().translate(0.0, 0.0, 0.0), new Vector3d(1.378 / 2, 0.05, 2.648 / 2), new Vector3d(1.378, 0.1, 2.648), Material.Rail, new Vector3d(), new Vector3d(), new HashSet<>(), 5.97219e24, false)});
        PhysicsEngine testEngine = new PhysicsEngine(Arrays.asList(testEntity1, testEntity2), 0.0) {
            @Override void update() {
                List<Contact> contacts = getContacts();

                assert contacts.size() == 1;

                Contact contact = contacts.get(0);
                assert contact.A == testEntity1.getPhysicsComponent();
                assert contact.B == testEntity2.getPhysicsComponent();
                assertEquals(contact.point.x, testEntity1.getPhysicsComponent().position.x, epsilon);
                assertEquals(contact.point.y, testEntity1.getPhysicsComponent().position.y - testEntity1.getPhysicsComponent().radius, epsilon);
                assertEquals(contact.point.z, testEntity1.getPhysicsComponent().position.z, epsilon);
                assertEquals(contact.normal.dot(new Vector3d(0.0, -1.0, 0.0)), 1.0, epsilon);
                // If A and B are correct, the coefficients are implicitly also correct
            }
            @Override public void destroy() { }
        };

        testEngine.update();
    }

    /**
     * Test if a single constraint is computed correctly
     */
    @Test
    public void testComputeConstraints() {
        Entity testEntity1 = new Entity("1", new Component.Type[]{Component.Type.Physics},
                new Component[]{new PhysicsSphere(Material.Inelastic, new Vector3d(0.0, 0.10715, -0.5), new Vector3d(0.0, 0.0, 0.0),  new Quaterniond().identity(), new Vector3d(0.0 * (3.0/ 0.05715), 0.0, 0.0), new HashSet<>(Collections.singletonList(new Gravity())), 0.163, 0.05715, false)});
        Entity testEntity2 = new Entity("3", new Component.Type[]{Component.Type.Physics},
                new Component[]{new PhysicsBox(new Matrix4d().translate(0.0, 0.0, 0.0), new Vector3d(1.378 / 2, 0.05, 2.648 / 2), new Vector3d(1.378, 0.1, 2.648), Material.Rail, new Vector3d(), new Vector3d(), new HashSet<>(), 5.97219e24, false)});
        Entity testEntity3 = new Entity("3", new Component.Type[]{Component.Type.Physics},
                new Component[]{new PhysicsBox(new Matrix4d().translate(0.0, -1.0, 0.0), new Vector3d(1.378 / 2, 0.05, 2.648 / 2), new Vector3d(1.378, 0.1, 2.648), Material.Rail, new Vector3d(), new Vector3d(), new HashSet<>(), 5.97219e24, true)});
        Entity testEntity4 = new Entity("4", new Component.Type[]{Component.Type.Physics},
                new Component[]{new PhysicsBox(new Matrix4d().translate(0.0, 0.136 - 0.05, -2.594 / 2), new Vector3d(1.378 / 2, 0.036, 0.054 / 2), new Vector3d(0.054, 0.072, 1.378), Material.Rail, new Vector3d(), new Vector3d(), new HashSet<>(), 5.97219e24, true)});
        Entity testEntity5 = new Entity("5", new Component.Type[]{Component.Type.Physics},
                new Component[]{new PhysicsBox(new Matrix4d().translate(0.0, 0.136 - 0.05, 2.594 / 2), new Vector3d(1.378 / 2, 0.036, 0.054 / 2), new Vector3d(0.054, 0.072, 1.378), Material.Rail, new Vector3d(), new Vector3d(), new HashSet<>(), 5.97219e24, true)});
        Entity testEntity6 = new Entity("6", new Component.Type[]{Component.Type.Physics},
                new Component[]{new PhysicsBox(new Matrix4d().translate(1.324 / 2, 0.136 - 0.05, 0.0), new Vector3d(0.054 / 2, 0.036, 2.54 / 2), new Vector3d(2.54, 0.072, 0.054), Material.Rail, new Vector3d(), new Vector3d(), new HashSet<>(), 5.97219e24, true)});
        Entity testEntity7 = new Entity("7", new Component.Type[]{Component.Type.Physics},
                new Component[]{new PhysicsBox(new Matrix4d().translate(-1.324 / 2, 0.136 - 0.05, 0.0), new Vector3d(0.054 / 2, 0.036, 2.54 / 2), new Vector3d(2.54, 0.072, 0.054), Material.Rail, new Vector3d(), new Vector3d(), new HashSet<>(), 5.97219e24, true)});
        PhysicsEngine testEngine = new PhysicsEngine(Arrays.asList(testEntity1, testEntity2, testEntity3, testEntity4, testEntity5, testEntity6, testEntity7), 0.0) {
            @Override void update() {
                List<Entity> dynamicEntities = entities.stream().filter(entity -> !entity.getPhysicsComponent().isStatic()).collect(Collectors.toList());
                List<Contact> contacts = getContacts();

                DoubleMatrix J = new DoubleMatrix(3, 6 * 2), e = new DoubleMatrix(3, 1), bounce = new DoubleMatrix(3, 1);
                computeConstraints(dynamicEntities, contacts, J, e, bounce);
                Contact contact = contacts.get(0);
                Vector3d rA = contact.point.sub(contact.A.position, new Vector3d()), rB = contact.point.sub(contact.B.position, new Vector3d());
                Vector3d aA = rA.cross(contact.normal, new Vector3d()), aB = rB.cross(contact.normal.negate(new Vector3d()));


                assertArrayEquals(J.toArray(), new double[] {
                        contact.normal.x, 0.0, 0.0, 0.0, contact.normal.y, 0.0, 0.0, 0.0, contact.normal.z, 0.0, -aA.z, aA.y, aA.z, 0.0, -aA.x, -aA.y, aA.x, 0.0,
                        -contact.normal.x, 0.0, 0.0, 0.0, -contact.normal.y, 0.0, 0.0, 0.0, -contact.normal.z, 0.0, aB.z, -aB.y, -aB.z, 0.0, aB.x, aB.y, -aB.x, 0.0,
                }, epsilon);
                assertArrayEquals(e.toArray(), Transforms.jomlVectorToJBLASVector(new Vector3d(contact.penetration)).toArray(), epsilon);
            }
            @Override public void destroy() { }
        };

        testEngine.update();
    }

    /**
     * Test if a timestep is performed correctly if there is one simple inelastic collision
     */
    @Test
    public void testSingleCollision() {
        Force torque = new Force() {
            @Override
            public boolean isFulfilled(PhysicsComponent physicsComponent) {
                return true;
            }

            @Override
            public Map.Entry<Vector3d, Vector3d> applyForce(PhysicsComponent physicsComponent) {
                return new AbstractMap.SimpleEntry<>(new Vector3d(0.0), new Vector3d(0.0, -2 * Math.PI, 0.0));
            }
        };
        PhysicsComponent testPhysComp1 = new PhysicsSphere(Material.Inelastic, new Vector3d(0.0, 0.10715, -0.5), new Vector3d(0.0, -10.0, 1.0),  new Quaterniond().identity(), new Vector3d(0.0, 0.0, 0.0), new HashSet<>(Collections.singletonList(torque)), 0.163, 0.05715, false);
        PhysicsComponent testPhysComp2 = new PhysicsSphere(Material.Inelastic, new Vector3d(0.0, 0.05, -0.5), new Vector3d(0.0, 10.0, 1.0),  new Quaterniond().identity(), new Vector3d(0.0, 0.0, 0.0), new HashSet<>(Collections.singletonList(torque)), 0.163, 0.05715, false);
        Entity testEntity1 = new Entity("", new Component.Type[]{Component.Type.Physics},
                new Component[]{testPhysComp1});
        Entity testEntity2 = new Entity("", new Component.Type[]{Component.Type.Physics},
                new Component[]{testPhysComp2});
        PhysicsEngine testEngine = new PhysicsEngine(Arrays.asList(testEntity1, testEntity2), 0.0, 10e-15, 0.1, 1e-5) {
            @Override void update() { timeStep(0.01); }
            @Override public void destroy() { }
        };

        Contact contact = testEngine.getContacts().get(0);
        double c = contact.penetration.length();

        testEngine.update();

        assertArrayEquals(Transforms.jomlVectorToJBLASVector(testPhysComp1.velocity).toArray(), new double[] {0.0, 0.1 * c / (0.01 * 2), 1.0}, epsilon);
        assertArrayEquals(Transforms.jomlVectorToJBLASVector(testPhysComp1.angularVelocity).toArray(), new double[] {0.0, -295.05284265823724, 0.0}, epsilon);
        assertArrayEquals(Transforms.jomlVectorToJBLASVector(testPhysComp1.position).toArray(), new double[] {0.0, 0.10715 + 0.1 * c / 2, -0.49}, epsilon);
        assertArrayEquals(Transforms.jomlQuaternionToJBLASVector(testPhysComp1.orientation).toArray(), new double[] {0.0, -0.8277551782105788, 0.0, 0.5610894446927096}, epsilon);
        assertArrayEquals(Transforms.jomlMatrixToJBLASMatrix(testPhysComp1.worldMatrix).toArray(), new double[] {-0.37035727010885355, 0.0, 0.9288893865673766, 0.0, -0.0, 0.9999999999999998, 0.0, 0.0, -0.9288893865673766, -0.0, -0.37035727010885355, 0.0, 0.0, 0.10715 + 0.1 * c / 2, -0.49, 1.0}, epsilon);
        assertArrayEquals(Transforms.jomlMatrixToJBLASMatrix(testPhysComp1.worldFrameInertia).toArray(), new double[] {2.1295118699999992E-4, -0.0, -1.3552527156068805E-20, 0.0, 2.1295118699999992E-4, 0.0, 1.3552527156068805E-20, 0.0, 2.1295118699999992E-4}, epsilon);
        assertArrayEquals(Transforms.jomlMatrixToJBLASMatrix(testPhysComp1.worldFrameInertiaInv).toArray(), new double[] {4695.911838237372, 0.0, 2.988547451027685E-13, 0.0, 4695.911838237372, -0.0, -2.988547451027685E-13, -0.0, 4695.911838237372}, epsilon);

        assertArrayEquals(Transforms.jomlVectorToJBLASVector(testPhysComp2.velocity).toArray(), new double[] {0.0, 0.1 * -c / (0.01 * 2), 1.0}, epsilon);
        assertArrayEquals(Transforms.jomlVectorToJBLASVector(testPhysComp2.angularVelocity).toArray(), new double[] {0.0, -295.05284265823724, 0.0}, epsilon);
        assertArrayEquals(Transforms.jomlVectorToJBLASVector(testPhysComp2.position).toArray(), new double[] {0.0, 0.05 - 0.1 * c / 2, -0.49}, epsilon);
        assertArrayEquals(Transforms.jomlQuaternionToJBLASVector(testPhysComp2.orientation).toArray(), new double[] {0.0, -0.8277551782105788, 0.0, 0.5610894446927096}, epsilon);
        assertArrayEquals(Transforms.jomlMatrixToJBLASMatrix(testPhysComp2.worldMatrix).toArray(), new double[] {-0.37035727010885355, 0.0, 0.9288893865673766, 0.0, -0.0, 0.9999999999999998, 0.0, 0.0, -0.9288893865673766, -0.0, -0.37035727010885355, 0.0, 0.0, 0.05 - 0.1 * c / 2, -0.49, 1.0}, epsilon);
        assertArrayEquals(Transforms.jomlMatrixToJBLASMatrix(testPhysComp2.worldFrameInertia).toArray(), new double[] {2.1295118699999992E-4, -0.0, -1.3552527156068805E-20, 0.0, 2.1295118699999992E-4, 0.0, 1.3552527156068805E-20, 0.0, 2.1295118699999992E-4}, epsilon);
        assertArrayEquals(Transforms.jomlMatrixToJBLASMatrix(testPhysComp2.worldFrameInertiaInv).toArray(), new double[] {4695.911838237372, 0.0, 2.988547451027685E-13, 0.0, 4695.911838237372, -0.0, -2.988547451027685E-13, -0.0, 4695.911838237372}, epsilon);
    }

    /**
     * Test if sustained contact by a ball affected by gravity and the ground is performed correctly (the ball doesn't fall into the table or fly above it) for 1000 iterations
     */
    @Test
    public void testSustainedContact() {
        PhysicsComponent testPhysComp1 = new PhysicsSphere(Material.Inelastic, new Vector3d(0.0, 0.10715, -0.5), new Vector3d(0.0, -10.0, 1.0),  new Quaterniond().identity(), new Vector3d(0.0, 0.0, 0.0), new HashSet<>(Collections.singletonList(new Gravity())), 0.163, 0.05715, false);
        PhysicsComponent testPhysComp2 = new PhysicsBox(new Matrix4d().translate(0.0, 0.0, 0.0), new Vector3d(50, 0.05, 50), new Vector3d(100, 0.1, 100), Material.Rail, new Vector3d(), new Vector3d(), new HashSet<>(), 5.97219e24, true);
        Entity testEntity1 = new Entity("", new Component.Type[]{Component.Type.Physics},
                new Component[]{testPhysComp1});
        Entity testEntity2 = new Entity("", new Component.Type[]{Component.Type.Physics},
                new Component[]{testPhysComp2});
        PhysicsEngine testEngine = new PhysicsEngine(Arrays.asList(testEntity1, testEntity2), 0.0, 10e-20, 0.1, 1e-5) {
            @Override void update() { timeStep(0.01); }
            @Override public void destroy() { }
        };

        for (int i = 0; i < 1000; i++) {
            testEngine.update();

            assert (testPhysComp1.velocity.y <= epsilon && testPhysComp1.velocity.y >= -epsilon) : "Test failed at iteration " + i;
            assert (testPhysComp1.position.y <= 0.10715 + epsilon && testPhysComp1.position.y >= 0.10715 - epsilon) : "Test failed at iteration " + i;
        }
    }

    /**
     * Test if a inelastic collision during sustained contact is performed correctly (both stay at the correct height and they do not go through each other)
     */
    @Test
    public void testCollisionDuringSustainedContact() {
        PhysicsComponent testPhysComp1 = new PhysicsSphere(Material.Inelastic, new Vector3d(0.0, 0.10715, 0.0), new Vector3d(0.0, 0.0, 1.0),  new Quaterniond().identity(), new Vector3d(0.0, 0.0, 0.0), new HashSet<>(Collections.singletonList(new Gravity())), 0.163, 0.05715, false);
        PhysicsComponent testPhysComp2 = new PhysicsSphere(Material.Inelastic, new Vector3d(0.0, 0.10715, 0.04715), new Vector3d(0.0, 0.0, 0.0),  new Quaterniond().identity(), new Vector3d(0.0, 0.0, 0.0), new HashSet<>(Collections.singletonList(new Gravity())), 0.163, 0.05715, false);
        PhysicsComponent testPhysComp3 = new PhysicsBox(new Matrix4d().translate(0.0, 0.0, 0.0), new Vector3d(50, 0.05, 50), new Vector3d(100, 0.1, 100), Material.Rail, new Vector3d(), new Vector3d(), new HashSet<>(), 5.97219e24, true);
        Entity testEntity1 = new Entity("", new Component.Type[]{Component.Type.Physics},
                new Component[]{testPhysComp1});
        Entity testEntity2 = new Entity("", new Component.Type[]{Component.Type.Physics},
                new Component[]{testPhysComp2});
        Entity testEntity3 = new Entity("", new Component.Type[]{Component.Type.Physics},
                new Component[]{testPhysComp3});
        PhysicsEngine testEngine = new PhysicsEngine(Arrays.asList(testEntity1, testEntity2, testEntity3), 0.0, 10e-20, 0.1, 1e-5) {
            @Override void update() { timeStep(0.01); }
            @Override public void destroy() { }
        };
        Vector3d[] closestPoints = testPhysComp1.collisionShape.findClosestPoints(testPhysComp2.collisionShape);
        double initialPen = closestPoints[1].sub(closestPoints[0], new Vector3d()).length();

        
        testEngine.update();


        assertEquals(testPhysComp1.velocity.y, 0.0, epsilon);
        assertEquals(testPhysComp2.velocity.y, 0.0, epsilon);
        assertEquals(testPhysComp1.position.y, 0.10715, epsilon);
        assertEquals(testPhysComp2.position.y, 0.10715, epsilon);

        closestPoints = testPhysComp1.collisionShape.findClosestPoints(testPhysComp2.collisionShape);
        double newPen = closestPoints[1].sub(closestPoints[0], new Vector3d()).length();
        assert testPhysComp1.position.z < testPhysComp2.position.z;
        assert initialPen > newPen;
        assertEquals(newPen, 0.9 * initialPen, epsilon);

        // Similar to general inelastic collision the compensation velocity for the penetration (v = dx * dt) is split up between the two bodies:
        // The rightmost one's velocity is increased while the other one's is reduced to ultimately reduce their penetration
        double vel = testPhysComp2.velocity.z + testPhysComp1.velocity.z;
        double velGap = 0.1 * initialPen / 0.01;
        assertEquals(testPhysComp2.velocity.z, (vel + velGap) / 2.0, epsilon);
        assertEquals(testPhysComp1.velocity.z, (vel - velGap) / 2.0, epsilon);
    }

    /**
     *  Test if a timestep is performed correctly if there is one simple elastic collision
     */
    @Test
    public void testSingleElasticCollision() {
        Force torque = new Force() {
            @Override
            public boolean isFulfilled(PhysicsComponent physicsComponent) {
                return true;
            }

            @Override
            public Map.Entry<Vector3d, Vector3d> applyForce(PhysicsComponent physicsComponent) {
                return new AbstractMap.SimpleEntry<>(new Vector3d(0.0), new Vector3d(0.0, -2 * Math.PI, 0.0));
            }
        };
        PhysicsComponent testPhysComp1 = new PhysicsSphere(Material.Elastic, new Vector3d(0.0, 0.10715, -0.5), new Vector3d(0.0, -10.0, 1.0),  new Quaterniond().identity(), new Vector3d(0.0, 0.0, 0.0), new HashSet<>(Collections.singletonList(torque)), 0.163, 0.05715, false);
        PhysicsComponent testPhysComp2 = new PhysicsSphere(Material.Elastic, new Vector3d(0.0, 0.05, -0.5), new Vector3d(0.0, 10.0, 1.0),  new Quaterniond().identity(), new Vector3d(0.0, 0.0, 0.0), new HashSet<>(Collections.singletonList(torque)), 0.163, 0.05715, false);
        Entity testEntity1 = new Entity("", new Component.Type[]{Component.Type.Physics},
                new Component[]{testPhysComp1});
        Entity testEntity2 = new Entity("", new Component.Type[]{Component.Type.Physics},
                new Component[]{testPhysComp2});
        PhysicsEngine testEngine = new PhysicsEngine(Arrays.asList(testEntity1, testEntity2), 0.0, 10e-15, 0.1, 1e-5) {
            @Override void update() { timeStep(0.01); }
            @Override public void destroy() { }
        };

        Contact contact = testEngine.getContacts().get(0);
        double c = contact.penetration.length();

        testEngine.update();

        assertArrayEquals(Transforms.jomlVectorToJBLASVector(testPhysComp1.velocity).toArray(), new double[] {0.0, 0.1 * c / (0.01 * 2) + 10, 1.0}, epsilon);
        assertArrayEquals(Transforms.jomlVectorToJBLASVector(testPhysComp1.angularVelocity).toArray(), new double[] {0.0, -295.05284265823724, 0.0}, epsilon);
        assertArrayEquals(Transforms.jomlVectorToJBLASVector(testPhysComp1.position).toArray(), new double[] {0.0, 0.10715 + 0.1 * c / 2 + 10 * 0.01, -0.49}, epsilon);
        assertArrayEquals(Transforms.jomlQuaternionToJBLASVector(testPhysComp1.orientation).toArray(), new double[] {0.0, -0.8277551782105788, 0.0, 0.5610894446927096}, epsilon);
        assertArrayEquals(Transforms.jomlMatrixToJBLASMatrix(testPhysComp1.worldMatrix).toArray(), new double[] {-0.37035727010885355, 0.0, 0.9288893865673766, 0.0, -0.0, 0.9999999999999998, 0.0, 0.0, -0.9288893865673766, -0.0, -0.37035727010885355, 0.0, 0.0, 0.10715 + 0.1 * c / 2 + 10 * 0.01, -0.49, 1.0}, epsilon);
        assertArrayEquals(Transforms.jomlMatrixToJBLASMatrix(testPhysComp1.worldFrameInertia).toArray(), new double[] {2.1295118699999992E-4, -0.0, -1.3552527156068805E-20, 0.0, 2.1295118699999992E-4, 0.0, 1.3552527156068805E-20, 0.0, 2.1295118699999992E-4}, epsilon);
        assertArrayEquals(Transforms.jomlMatrixToJBLASMatrix(testPhysComp1.worldFrameInertiaInv).toArray(), new double[] {4695.911838237372, 0.0, 2.988547451027685E-13, 0.0, 4695.911838237372, -0.0, -2.988547451027685E-13, -0.0, 4695.911838237372}, epsilon);

        assertArrayEquals(Transforms.jomlVectorToJBLASVector(testPhysComp2.velocity).toArray(), new double[] {0.0, 0.1 * -c / (0.01 * 2) - 10, 1.0}, epsilon);
        assertArrayEquals(Transforms.jomlVectorToJBLASVector(testPhysComp2.angularVelocity).toArray(), new double[] {0.0, -295.05284265823724, 0.0}, epsilon);
        assertArrayEquals(Transforms.jomlVectorToJBLASVector(testPhysComp2.position).toArray(), new double[] {0.0, 0.05 - 0.1 * c / 2 - 10 * 0.01, -0.49}, epsilon);
        assertArrayEquals(Transforms.jomlQuaternionToJBLASVector(testPhysComp2.orientation).toArray(), new double[] {0.0, -0.8277551782105788, 0.0, 0.5610894446927096}, epsilon);
        assertArrayEquals(Transforms.jomlMatrixToJBLASMatrix(testPhysComp2.worldMatrix).toArray(), new double[] {-0.37035727010885355, 0.0, 0.9288893865673766, 0.0, -0.0, 0.9999999999999998, 0.0, 0.0, -0.9288893865673766, -0.0, -0.37035727010885355, 0.0, 0.0, 0.05 - 0.1 * c / 2 - 10 * 0.01, -0.49, 1.0}, epsilon);
        assertArrayEquals(Transforms.jomlMatrixToJBLASMatrix(testPhysComp2.worldFrameInertia).toArray(), new double[] {2.1295118699999992E-4, -0.0, -1.3552527156068805E-20, 0.0, 2.1295118699999992E-4, 0.0, 1.3552527156068805E-20, 0.0, 2.1295118699999992E-4}, epsilon);
        assertArrayEquals(Transforms.jomlMatrixToJBLASMatrix(testPhysComp2.worldFrameInertiaInv).toArray(), new double[] {4695.911838237372, 0.0, 2.988547451027685E-13, 0.0, 4695.911838237372, -0.0, -2.988547451027685E-13, -0.0, 4695.911838237372}, epsilon);
    }

    /**
     *  Test if a simple system with elastic collisions gains energy over time
     */
    @Test
    public void testElasticCollisionsSystemEnergy() {
        PhysicsComponent testPhysComp1 = new PhysicsSphere(Material.Ball, new Vector3d(0.0, 0.10715, -0.5), new Vector3d(0.0, 0.0, 1.0),  new Quaterniond().identity(), new Vector3d(1 * (3.0/ 0.05715), 0.0, 0.0), new HashSet<>(Collections.singletonList(new Gravity())), 0.163, 0.05715, false);
        PhysicsComponent testPhysComp2 = new PhysicsSphere(Material.Ball, new Vector3d(0.0, 0.10715, 0.5), new Vector3d(0.0, 0.0, -0.8),  new Quaterniond().identity(), new Vector3d(-0.8 * (3.0/ 0.05715), 0.0, 0.0), new HashSet<>(Collections.singletonList(new Gravity())), 0.163, 0.05715, false);
        PhysicsComponent testPhysComp3 = new PhysicsBox(new Matrix4d().translate(0.0, 0.0, 0.0), new Vector3d(1.378 / 2, 0.05, 2.648 / 2), new Vector3d(1.378, 0.1, 2.648), Material.Rail, new Vector3d(), new Vector3d(), new HashSet<>(), 5.97219e24, true);
        PhysicsComponent testPhysComp4 = new PhysicsBox(new Matrix4d().translate(0.0, 0.136 - 0.05, -2.594 / 2), new Vector3d(1.378 / 2, 0.036, 0.054 / 2), new Vector3d(0.054, 0.072, 1.378), Material.Rail, new Vector3d(), new Vector3d(), new HashSet<>(), 5.97219e24, true);
        PhysicsComponent testPhysComp5 = new PhysicsBox(new Matrix4d().translate(0.0, 0.136 - 0.05, 2.594 / 2), new Vector3d(1.378 / 2, 0.036, 0.054 / 2), new Vector3d(0.054, 0.072, 1.378), Material.Rail, new Vector3d(), new Vector3d(), new HashSet<>(), 5.97219e24, true);
        PhysicsComponent testPhysComp6 = new PhysicsBox(new Matrix4d().translate(1.324 / 2, 0.136 - 0.05, 0.0), new Vector3d(0.054 / 2, 0.036, 2.54 / 2), new Vector3d(2.54, 0.072, 0.054), Material.Rail, new Vector3d(), new Vector3d(), new HashSet<>(), 5.97219e24, true);
        PhysicsComponent testPhysComp7 = new PhysicsBox(new Matrix4d().translate(-1.324 / 2, 0.136 - 0.05, 0.0), new Vector3d(0.054 / 2, 0.036, 2.54 / 2), new Vector3d(2.54, 0.072, 0.054), Material.Rail, new Vector3d(), new Vector3d(), new HashSet<>(), 5.97219e24, true);
        Entity testEntity1 = new Entity("", new Component.Type[]{Component.Type.Physics},
                new Component[]{testPhysComp1});
        Entity testEntity2 = new Entity("", new Component.Type[]{Component.Type.Physics},
                new Component[]{testPhysComp2});
        Entity testEntity3 = new Entity("", new Component.Type[]{Component.Type.Physics},
                new Component[]{testPhysComp3});
        Entity testEntity4 = new Entity("", new Component.Type[]{Component.Type.Physics},
                new Component[]{testPhysComp4});
        Entity testEntity5 = new Entity("", new Component.Type[]{Component.Type.Physics},
                new Component[]{testPhysComp5});
        Entity testEntity6 = new Entity("", new Component.Type[]{Component.Type.Physics},
                new Component[]{testPhysComp6});
        Entity testEntity7 = new Entity("", new Component.Type[]{Component.Type.Physics},
                new Component[]{testPhysComp7});
        PhysicsEngine testEngine = new PhysicsEngine(Arrays.asList(testEntity1, testEntity2, testEntity3, testEntity4, testEntity5, testEntity6, testEntity7), 0.0, 10e-20, 0.05, 1e-5) {
            @Override void update() { timeStep(0.01); }
            @Override public void destroy() { }
        };

        double oldEnergy = testEngine.getEnergy();
        for (int i = 0; i < 100; i++) {
            testEngine.update();

            double newEnergy = testEngine.getEnergy();
            System.out.println(newEnergy + ", " + oldEnergy + ", " + (newEnergy - oldEnergy));
            assert (newEnergy - oldEnergy) <= epsilon : "Test failed at iteration " + i;
            oldEnergy = newEnergy;
        }
    }

}
